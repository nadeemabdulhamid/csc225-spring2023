# Queue Applications

Start a new BlueJ project named **hw26-queue-apps**. There are two tasks to work on below.

---

# Task 1 - Palindromes

A palindrome is a string of characters that reads the same from left to right as it does from right to left. Write a method named `checkPalindrome` in a class named `Palindrome` that takes a string `str` and determines if the string is a palindrome, using only a **stack** and a **queue**. Observe that if you add a certain sequence of elements to both a stack and a queue, you can then retrieve them from those data structures in opposite orders very easily due to the nature of the two structures. Exploit this fact to implement `checkPalindrome` with exactly *n* sequential accesses to the input string, where *n* = *len*(`str`). You should make use of the built-in Java implementations of the stack and queue data structure under `java.util.Stack` and `java.util.Queue`.

Examples of valid palindromes:

    ""
    "a"
    "aa"
    "aaa"
    "aba"
    "abba"
    "Taco cat"
    "Madam, I'm Adam"
    "A man, a plan, a canal: Panama"
    "Doc, note: I dissent. A fast never prevents a fatness. I diet on cod."

Your implementation should **ignore** white space and punctuation, and all comparisons should be case-insensitive.* Include a `main` method that reads strings from the user and reports if they are palindromes or not.

- The [`Character` class's `toLowerCase` method](https://stackoverflow.com/questions/13113010/how-to-turn-uppercase-to-lowercase-using-the-charat-method) may be useful.

---

# Task 2 - Sieve of Eratosthenes

Implement a class named `Sieve` that computes all prime numbers up to some given integer `n`. The technique you are to use was developed by a Greek named Eratosthenes who lived in the third century BC. The technique is known as the Sieve of Eratosthenes.

The algorithm is described by the following pseudocode:

    create a queue of numbers and fill it with the consecutive integers 2 through n inclusive.
    create an empty queue to store primes.
    do {
        obtain the next prime p by removing the first value in the queue of numbers.
        put p into the queue of primes.
        go through the queue of numbers, eliminating numbers divisible by p.
    } while (p < sqrt(n))
    all remaining values in numbers queue are prime, so transfer them to primes queue

You are to use the `Queue` interface provided by Java. When you want to construct a concrete `Queue` object, you must make it of type `ArrayDequeue` (provided by the `java.util` package).

You should define a class called `Sieve` with the following public methods:

| Method | Description |
|--------|-------------|
| `Sieve()` | Constructs a sieve object. |
| `void computeTo(int n)` | This is the method that should implement the sieve algorithm.  All prime computations must be implemented using this algorithm.  The method should compute all primes up to and including `n`.  It should throw an `IllegalArgumentException` if `n` is less than 2. |
| `void reportResults()` | This method should print the primes to System.out.  It should throw an `IllegalStateException` if no legal call has been made yet on the `computeTo` method.  It is okay for it to have an extra space at the end of each line. |
| `int getMax()` | This is a convenience method that will let the client find out the value of `n` that was used the last time `computeTo` was called.  It should throw an `IllegalStateException` if no legal call has been made yet on the `computeTo` method. |
| `int getCount()` | This method should return the number of primes that were found on the last call on `computeTo`.  It should throw an `IllegalStateException` if no legal call has been made yet on the `computeTo` method. |

Your `reportResults` method should print the maximum `n` used and should then show a list of the primes, 12 per line with a space after each prime.  Notice that there is no guarantee that the number of primes will be a multiple of 12.  The calls on `reportResults` must exactly reproduce the format of the sample output below.  The final line of output that appears in the log reporting the percentage of primes is generated by the `main` program, not by the call on `reportResults`.

Make sure you use references of type `Queue` for this assignment.  You should also be sure to specify that we want queues of `Integer` (`Queue<Integer>` and `ArrayDequeue<Integer>`).

You must guarantee that your object is never in a corrupt state.  For example, your sieve object might be asked to compute up to one value of n and then asked to compute up to a different value of `n` without a call on `reportResults` ever being made.  Similarly, your object might be asked to compute up to some value of `n` and then be asked to `reportResults` more than once.  Each call on `reportResults`, `getMax` and `getCount` should behave appropriately given the previous call on computeTo, no matter how often they are called or in what order.  Finally, notice that if `reportResults`, `getMax` or `getCount` are called before a legal call on `computeTo`, they throw an exception to indicate that the operation is not legal given the objectâ€™s state.

In terms of correctness, your class must provide all of the functionality described above.  In terms of style, you will be evaluated on your use of comments, good variable names, consistent indentation and good coding style to implement these operations. 

Use the code in [SieveMain.java](SieveMain.java) to construct a sieve object and make calls on it based on values entered by the user.  You can use this program to test your class, but keep in mind that it does not test the internal consistency of your object.

Also view [sieve.txt](sieve.txt) for a longer sample log of execution than the one below.

### Sample Output

    This program computes all prime numbers up to a
    maximum using the Sieve of Eratosthenes.

    Maximum n to compute (0 to quit)? 20
    
    Primes up to 20 are as follows:
    2 3 5 7 11 13 17 19
    % of primes = 40
    
    Maximum n to compute (0 to quit)? 100
    
    Primes up to 100 are as follows:
    2 3 5 7 11 13 17 19 23 29 31 37
    41 43 47 53 59 61 67 71 73 79 83 89
    97
    % of primes = 25

    Maximum n to compute (0 to quit)? 0









